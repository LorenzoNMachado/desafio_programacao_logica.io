<!doctype html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Transformador FOL ‚Äî Prenex / CNF / DNF / Cl√°usal</title>
  
  <script>
    window.MathJax = {tex:{inlineMath:[['$','$'],['\\(','\\)']]}, svg:{fontCache:'global'}};
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  
  <style>
    :root {
      --bg-primary: #f4f7fc;
      --bg-secondary: #ffffff;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --accent-primary: #000000;
      --accent-gradient: linear-gradient(45deg, rgb(8, 8, 8), #565457);
      --border-color: #e2e8f0;
      --shadow-color: rgba(67, 71, 85, 0.12);
      --success-color: #22c55e;
      --error-color: #ef4444;
      --mono-font: "SF Mono", "Fira Code", Menlo, Monaco, "Courier New", monospace;
    }

    [data-theme="dark"] {
      --bg-primary: #121212;
      --bg-secondary: #1e1e1e;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --accent-primary: #ffffff;
      --accent-gradient: linear-gradient(45deg, #f7f7f7, #7d7a7e);
      --border-color: #334155;
      --shadow-color: rgba(0, 0, 0, 0.25);
    }

    body {
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; 
      background-color: var(--bg-primary); 
      color: var(--text-primary); 
      margin: 0; 
      padding: 24px;
      line-height: 1.6;
      transition: background-color 0.3s, color 0.3s;
    }
    
    .container {
        max-width: 800px;
        margin: 0 auto;
    }

    header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }

    h1 {
      font-size: 28px;
      font-weight: 800;
      color: var(--text-primary);
      margin: 0;
    }

    /* --- Theme Toggle --- */
    .theme-switch-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .theme-switch {
        display: inline-block;
        height: 24px;
        position: relative;
        width: 44px;
    }
    .theme-switch input {
        display: none;
    }
    .slider {
        background-color: #ccc;
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: .4s;
        border-radius: 24px;
    }
    .slider:before {
        background-color: #fff;
        bottom: 4px;
        content: "";
        height: 16px;
        left: 4px;
        position: absolute;
        transition: .4s;
        width: 16px;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: var(--accent-primary);
    }
    input:checked + .slider:before {
        transform: translateX(20px);
    }
    .theme-icon {
        font-size: 18px;
        color: var(--text-secondary);
    }

    .card {
        background-color: var(--bg-secondary);
        padding: 24px;
        border-radius: 16px;
        border: 1px solid var(--border-color);
        box-shadow: 0 8px 16px var(--shadow-color);
        margin-bottom: 24px;
        transition: background-color 0.3s, border-color 0.3s;
    }

    .small-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .symbols {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:16px;
    }
    .symbols button {
      border: 1px solid var(--border-color);
      background-color: var(--bg-primary);
      color: var(--text-primary);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .symbols button:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
      transform: translateY(-2px);
    }

    textarea#input {
      width: 100%;
      box-sizing: border-box;
      height: 120px;
      padding: 12px;
      font-family: var(--mono-font);
      font-size: 15px;
      border-radius: 8px;
      border: 2px solid var(--border-color);
      resize: vertical;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: border-color 0.2s, background-color 0.3s;
    }
    textarea#input:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .action-row {
      display:flex;
      gap: 12px;
      align-items:center;
      margin-top:16px;
    }
    button.primary {
      background: var(--accent-gradient);
      color:#fff;
      padding: 12px 20px;
      border-radius: 8px;
      border: 0;
      cursor: pointer;
      font-weight: 700;
      font-size: 16px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(138, 43, 226, 0.3);
    }
    button.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(138, 43, 226, 0.4);
    }
    button.ghost {
      background: transparent;
      border: 1px solid var(--border-color);
      padding: 11px 20px;
      border-radius: 8px;
      cursor: pointer;
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 16px;
      transition: all 0.2s ease;
    }
    button.ghost:hover {
      background-color: var(--bg-primary);
      border-color: var(--text-secondary);
    }

    .examples-section h4 {
        font-size: 16px;
        margin-top: 20px;
        margin-bottom: 10px;
        color: var(--text-primary);
    }
    .examples-grid {
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }
    .chip {
      padding: 8px 14px;
      border-radius: 20px;
      background: var(--bg-primary);
      color: var(--accent-primary);
      border: 1px solid var(--border-color);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    .chip:hover {
      background-color: var(--accent-primary);
      color: #fff;
      border-color: var(--accent-primary);
      transform: translateY(-2px);
    }
    
    #renderInput {
        padding: 16px;
        border-radius: 10px;
        background-color: var(--bg-primary);
        border: 1px solid var(--border-color);
        min-height: 40px;
        margin-top: 16px;
        overflow-wrap: break-word;
    }
    
    #resultsContainer h2 {
        font-size: 22px;
        font-weight: 700;
        margin-top: 16px;
        padding-bottom: 8px;
        border-bottom: 2px solid var(--border-color);
    }
    .step {
      display: flex;
      align-items: flex-start;
      gap: 16px;
      margin-top: 16px;
      padding: 20px;
      border-radius: 12px;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      transition: all 0.2s ease;
      overflow-wrap: break-word;
    }
    .step:hover {
      box-shadow: 0 6px 14px var(--shadow-color);
      border-color: var(--accent-primary);
    }
    .step-number {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--accent-gradient);
      color: white;
      font-weight: 700;
      font-size: 16px;
    }
    .step-content .title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text-primary);
      font-size: 16px;
    }
    .step-content .formula {
        font-size: 20px;
    }
    .step.error {
        border-color: var(--error-color);
    }

  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Transformador L√≥gico FOL</h1>
      <div class="theme-switch-wrapper">
        <span class="theme-icon">‚òÄÔ∏è</span>
        <label class="theme-switch">
          <input type="checkbox" id="theme-toggle">
          <span class="slider"></span>
        </label>
        <span class="theme-icon">üåô</span>
      </div>
    </header>

    <main>
      <div class="card" id="input-section">
        <div class="small-title">F√≥rmula em LaTeX</div>
        <div class="symbols">
          <button onclick="inserirSimbolo('\\forall ')">‚àÄ</button>
          <button onclick="inserirSimbolo('\\exists ')">‚àÉ</button>
          <button onclick="inserirSimbolo('\\neg ')">¬¨</button>
          <button onclick="inserirSimbolo('\\land ')">‚àß</button>
          <button onclick="inserirSimbolo('\\lor ')">‚à®</button>
          <button onclick="inserirSimbolo('\\rightarrow ')">‚Üí</button>
          <button onclick="inserirSimbolo('\\leftrightarrow ')">‚Üî</button>
        </div>
        <textarea id="input" spellcheck="false" placeholder="Digite a f√≥rmula aqui...">\forall x (Homem(x) \rightarrow Mortal(x))</textarea>
        <div class="action-row">
          <button class="primary" onclick="executarTudo()">Processar</button>
          <button class="ghost" onclick="limparTudo()">Limpar</button>
        </div>

        <div class="examples-section">
            <h4>B√°sicos</h4>
            <div class="examples-grid">
              <div class="chip" onclick="definirExemplo('P \\rightarrow (Q \\land R)')">P ‚Üí (Q ‚àß R)</div>
              <div class="chip" onclick="definirExemplo('\\neg(P \\land Q) \\leftrightarrow (\\neg P \\lor \\neg Q)')">Lei de De Morgan</div>
              <div class="chip" onclick="definirExemplo('(A \\lor B) \\land (\\neg A \\lor C)')">Forma Conjuntiva</div>
            </div>
            <h4>Com Quantificadores</h4>
            <div class="examples-grid">
                <div class="chip" onclick="definirExemplo('\\exists y \\forall x (P(x,y))')">‚àÉy ‚àÄx P(x,y)</div>
                <div class="chip" onclick="definirExemplo('\\neg \\exists x \\forall y (P(y) \\rightarrow Q(x))')">Nega√ß√£o de ‚àÉ‚àÄ</div>
            </div>
            <h4>Cl√°ssicos da L√≥gica</h4>
            <div class="examples-grid">
                <div class="chip" onclick="definirExemplo('\\forall x (Homem(x) \\rightarrow Mortal(x))')">S√≥crates √© mortal</div>
                <div class="chip" onclick="definirExemplo('\\forall x (Gato(x) \\rightarrow Animal(x))')">Gatos s√£o animais</div>
                <div class="chip" onclick="definirExemplo('\\exists x (Humano(x) \\land Voa(x))')">Humanos que voam?</div>
            </div>
        </div>
      </div>

      <div id="resultsContainer"></div>

    </main>
  </div>
  
  <script>
    // --- L√≥gica do Tema (Dark Mode) ---
    const themeToggle = document.getElementById('theme-toggle');
    const currentTheme = localStorage.getItem('theme');

    function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        if (theme === 'dark') {
            themeToggle.checked = true;
        } else {
            themeToggle.checked = false;
        }
    }

    if (currentTheme) {
        setTheme(currentTheme);
    } else {
        // Padr√£o para o tema do sistema
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setTheme(prefersDark ? 'dark' : 'light');
    }

    themeToggle.addEventListener('change', () => {
        setTheme(themeToggle.checked ? 'dark' : 'light');
    });

    // --- L√≥gica do Transformador (mesma do anterior) ---
    function tokenizar(s) {
      s = s.replace(/\$/g, ' ').trim();
      const tokens = [];
      const padroes = [
        ["WS", /^\s+/],["FORALL", /^(\\forall|‚àÄ)/],["EXISTS", /^(\\exists|‚àÉ)/],["NOT", /^(\\neg|¬¨|\\lnot)/],["AND", /^(\\land|‚àß)/],["OR", /^(\\lor|‚à®)/],["IMPLIES", /^(\\rightarrow|‚Üí)/],["IFF", /^(\\leftrightarrow|‚Üî)/],["LPAREN", /^\(/],["RPAREN", /^\)/],["COMMA", /^,/],["DOT", /^\./],["IDENT", /^[A-Za-z_][A-Za-z0-9_]*/],["UNKNOWN", /^./]
      ];
      let i = 0;
      while (i < s.length) {
        let matched = false;
        for (const [tipo, re] of padroes) {
          const m = s.slice(i).match(re);
          if (m) {
            matched = true;
            const tok = m[0];
            if (tipo !== "WS") tokens.push({ tipo, valor: tok });
            i += tok.length;
            break;
          }
        }
        if (!matched) i++;
      }
      return tokens;
    }

    function analisar(s) {
      const tokens = tokenizar(s);
      let pos = 0;
      const peek = () => tokens[pos] || null;
      const eat = tipo => (peek() && peek().tipo === tipo ? tokens[pos++] : null);
      const expect = tipo => {
        const t = eat(tipo);
        if (!t) throw new Error(`Esperado ${tipo}, encontrado ${peek()?.tipo || 'fim'}`);
        return t;
      };

      function formula() { return iff(); }
      function iff() {
        let left = implies();
        while (peek() && peek().tipo === "IFF") {
          eat("IFF");
          left = { tipo: 'iff', a: left, b: implies() };
        }
        return left;
      }
      function implies() {
        let left = or();
        if (peek() && peek().tipo === "IMPLIES") {
          eat("IMPLIES");
          left = { tipo: 'implies', a: left, b: implies() };
        }
        return left;
      }
      function or() {
        let left = and();
        while (peek() && peek().tipo === "OR") {
          eat("OR");
          left = { tipo: 'or', a: left, b: and() };
        }
        return left;
      }
      function and() {
        let left = unary();
        while (peek() && peek().tipo === "AND") {
          eat("AND");
          left = { tipo: 'and', a: left, b: unary() };
        }
        return left;
      }
      function unary() {
        const t = peek();
        if (!t) return null;
        if (t.tipo === "NOT") { eat("NOT"); return { tipo: 'not', a: unary() }; }
        if (t.tipo === "FORALL" || t.tipo === "EXISTS") {
          const qtipo = t.tipo === "FORALL" ? 'forall' : 'exists';
          eat(t.tipo);
          const vars = [];
          while (peek() && peek().tipo === "IDENT") vars.push(eat("IDENT").valor);
          if (!vars.length) throw new Error(`Esperado vari√°vel ap√≥s ${qtipo === 'forall' ? '‚àÄ' : '‚àÉ'}`);
          if (peek() && peek().tipo === "DOT") eat("DOT");
          let node = formula();
          if (!node) throw new Error(`Esperado f√≥rmula ap√≥s quantificador`);
          for (let i = vars.length - 1; i >= 0; i--) node = { tipo: qtipo, var: vars[i], a: node };
          return node;
        }
        if (t.tipo === "LPAREN") { eat("LPAREN"); const f = formula(); expect("RPAREN"); return f; }
        if (t.tipo === "IDENT") {
          const nome = eat("IDENT").valor;
          if (peek() && peek().tipo === "LPAREN") {
            eat("LPAREN");
            const args = [];
            if (peek() && peek().tipo !== "RPAREN") {
              while (true) {
                if (peek().tipo === "IDENT") args.push({ tipo: 'var', nome: eat("IDENT").valor });
                else throw new Error(`Token inesperado em argumentos: ${peek().tipo}`);
                if (peek() && peek().tipo === "COMMA") eat("COMMA");
                else break;
              }
            }
            expect("RPAREN");
            return { tipo: 'pred', nome, args };
          }
          return { tipo: 'pred', nome, args: [] };
        }
        throw new Error(`Token inesperado: ${t.tipo}`);
      }
      const ast = formula();
      if (pos < tokens.length) throw new Error(`Tokens extras encontrados: ${tokens.slice(pos).map(t => t.valor).join(' ')}`);
      return ast;
    }

    const clone = x => JSON.parse(JSON.stringify(x));

    function astParaLatex(a) {
      if (!a) return '';
      const wrap = (x, parent_op) => {
        if (!x) return '';
        const op_precedence = { 'iff': 1, 'implies': 2, 'or': 3, 'and': 4, 'not': 5, 'quant': 6 };
        const p_prec = op_precedence[parent_op] || 0;
        const c_prec = op_precedence[x.tipo] || 0;
        const needs_paren = c_prec < p_prec;
        return needs_paren ? `(${astParaLatex(x)})` : astParaLatex(x);
      };
      switch (a.tipo) {
        case 'pred': return a.args && a.args.length ? `${a.nome}(${a.args.map(termoParaLatex).join(',')})` : a.nome;
        case 'not': return `\\lnot ${wrap(a.a, 'not')}`;
        case 'and': return `${wrap(a.a, 'and')} \\land ${wrap(a.b, 'and')}`;
        case 'or': return `${wrap(a.a, 'or')} \\lor ${wrap(a.b, 'or')}`;
        case 'implies': return `${wrap(a.a, 'implies')} \\rightarrow ${wrap(a.b, 'implies')}`;
        case 'iff': return `${wrap(a.a, 'iff')} \\leftrightarrow ${wrap(a.b, 'iff')}`;
        case 'forall': return `\\forall ${a.var} \\, ${astParaLatex(a.a)}`;
        case 'exists': return `\\exists ${a.var} \\, ${astParaLatex(a.a)}`;
        case 'func': return a.args && a.args.length ? `${a.nome}(${a.args.map(termoParaLatex).join(',')})` : a.nome;
        case 'var': return a.nome;
        default: return '\\text{?}';
      }
    }

    function termoParaLatex(t) {
      if (!t) return '';
      if (t.tipo === 'var') return t.nome;
      if (t.tipo === 'func') return t.args && t.args.length ? `${t.nome}(${t.args.map(termoParaLatex).join(',')})` : t.nome;
      return t.nome || '?';
    }

    function eliminarImplicacoes(node) {
      if (!node) return node;
      switch (node.tipo) {
        case 'implies': return { tipo: 'or', a: { tipo: 'not', a: eliminarImplicacoes(node.a) }, b: eliminarImplicacoes(node.b) };
        case 'iff': return eliminarImplicacoes({ tipo: 'and', a: { tipo: 'implies', a: node.a, b: node.b }, b: { tipo: 'implies', a: node.b, b: node.a } });
        case 'and': case 'or': return { tipo: node.tipo, a: eliminarImplicacoes(node.a), b: eliminarImplicacoes(node.b) };
        case 'not': return { tipo: 'not', a: eliminarImplicacoes(node.a) };
        case 'forall': case 'exists': return { tipo: node.tipo, var: node.var, a: eliminarImplicacoes(node.a) };
        default: return clone(node);
      }
    }

    function paraNNF(node) {
      if (!node) return node;
      function nnf(n, neg) {
        if (!n) return null;
        if (n.tipo === 'not') return nnf(n.a, !neg);
        if (n.tipo === 'and' || n.tipo === 'or') {
          const a = nnf(n.a, neg), b = nnf(n.b, neg);
          if (neg) return n.tipo === 'and' ? { tipo: 'or', a, b } : { tipo: 'and', a, b };
          return { tipo: n.tipo, a, b };
        }
        if (n.tipo === 'forall' || n.tipo === 'exists') {
          if (neg) return { tipo: n.tipo === 'forall' ? 'exists' : 'forall', var: n.var, a: nnf(n.a, true) };
          return { tipo: n.tipo, var: n.var, a: nnf(n.a, false) };
        }
        return neg ? { tipo: 'not', a: clone(n) } : clone(n);
      }
      return nnf(node, false);
    }

    let skContador = 0, renomearContador = 0;
    const novoSk = (p = 'sk') => p + (++skContador);
    const novaVar = (p = 'v') => p + (++renomearContador);
    
    function getVars(node, bound = new Set()) {
      if (!node) return new Set();
      switch(node.tipo) {
        case 'pred': return new Set(node.args.map(arg => arg.nome));
        case 'not': return getVars(node.a, bound);
        case 'and': case 'or': case 'implies': case 'iff': return new Set([...getVars(node.a, bound), ...getVars(node.b, bound)]);
        case 'forall': case 'exists':
          const newBound = new Set(bound);
          newBound.add(node.var);
          return new Set([node.var, ...getVars(node.a, newBound)]);
        default: return new Set();
      }
    }

    function renomearVariaveisLigadas(node, mapping = {}, allVars = getVars(node)) {
      if (!node) return node;
      switch (node.tipo) {
        case 'forall':
        case 'exists': {
          let newVar = node.var;
          const newMapping = { ...mapping };
          let nv = novaVar(node.var);
          newMapping[node.var] = nv;
          return { tipo: node.tipo, var: nv, a: renomearVariaveisLigadas(node.a, newMapping, allVars) };
        }
        case 'and': case 'or': return { tipo: node.tipo, a: renomearVariaveisLigadas(node.a, mapping, allVars), b: renomearVariaveisLigadas(node.b, mapping, allVars) };
        case 'not': return { tipo: 'not', a: renomearVariaveisLigadas(node.a, mapping, allVars) };
        case 'pred': return { tipo: 'pred', nome: node.nome, args: node.args.map(arg => ({ ...arg, nome: mapping[arg.nome] || arg.nome })) };
        default: return clone(node);
      }
    }

    function puxarQuantificadores(node) {
      if (!node) return { quantificadores: [], matriz: null };
      if (node.tipo === 'forall' || node.tipo === 'exists') {
        const interno = puxarQuantificadores(node.a);
        return { quantificadores: [{ tipo: node.tipo, var: node.var }, ...interno.quantificadores], matriz: interno.matriz };
      }
      if (node.tipo === 'and' || node.tipo === 'or') {
        const E = puxarQuantificadores(node.a), D = puxarQuantificadores(node.b);
        return { quantificadores: [...E.quantificadores, ...D.quantificadores], matriz: { tipo: node.tipo, a: E.matriz, b: D.matriz } };
      }
      if (node.tipo === 'not') {
        const P = puxarQuantificadores(node.a);
        return { quantificadores: P.quantificadores, matriz: { tipo: 'not', a: P.matriz } };
      }
      return { quantificadores: [], matriz: clone(node) };
    }

    function construirPrenex(quantificadores, matriz) {
      let node = clone(matriz);
      for (let i = quantificadores.length - 1; i >= 0; --i)
        node = { tipo: quantificadores[i].tipo, var: quantificadores[i].var, a: node };
      return node;
    }

    function skolemizar(nodePrenex) {
      const qlist = [];
      let cur = nodePrenex;
      while (cur && (cur.tipo === 'forall' || cur.tipo === 'exists')) {
        qlist.push({ tipo: cur.tipo, var: cur.var });
        cur = cur.a;
      }
      let matriz = cur;
      const prefixoUniversal = [];
      const subs = {};
      for (const q of qlist) {
        if (q.tipo === 'forall') prefixoUniversal.push(q.var);
        else {
          subs[q.var] = prefixoUniversal.length === 0
            ? { tipo: 'func', nome: novoSk('c'), args: [] }
            : { tipo: 'func', nome: novoSk('f'), args: prefixoUniversal.map(v => ({ tipo: 'var', nome: v })) };
        }
      }
      function aplicarSubs(node) {
        if (!node) return node;
        switch (node.tipo) {
          case 'pred': return { tipo: 'pred', nome: node.nome, args: node.args.map(aplicarTermo) };
          case 'and': case 'or': return { tipo: node.tipo, a: aplicarSubs(node.a), b: aplicarSubs(node.b) };
          case 'not': return { tipo: 'not', a: aplicarSubs(node.a) };
          default: return clone(node);
        }
      }
      function aplicarTermo(t) {
        if (!t) return t;
        if (t.tipo === 'var') return subs[t.nome] ? subs[t.nome] : t;
        if (t.tipo === 'func') return { tipo: 'func', nome: t.nome, args: t.args.map(aplicarTermo) };
        return t;
      }
      return aplicarSubs(matriz);
    }

    function paraCNF(node) {
      if (!node) return node;
      if (node.tipo === 'and') return { tipo: 'and', a: paraCNF(node.a), b: paraCNF(node.b) };
      if (node.tipo === 'or') {
        const A = paraCNF(node.a), B = paraCNF(node.b);
        if (A.tipo === 'and') return paraCNF({ tipo: 'and', a: { tipo: 'or', a: A.a, b: B }, b: { tipo: 'or', a: A.b, b: B } });
        if (B.tipo === 'and') return paraCNF({ tipo: 'and', a: { tipo: 'or', a: A, b: B.a }, b: { tipo: 'or', a: A, b: B.b } });
        return { tipo: 'or', a: A, b: B };
      }
      if (node.tipo === 'not') return { tipo: 'not', a: paraCNF(node.a) };
      return clone(node);
    }

    function paraDNF(node) {
      if (!node) return node;
      if (node.tipo === 'or') return { tipo: 'or', a: paraDNF(node.a), b: paraDNF(node.b) };
      if (node.tipo === 'and') {
        const A = paraDNF(node.a), B = paraDNF(node.b);
        if (A.tipo === 'or') return paraDNF({ tipo: 'or', a: { tipo: 'and', a: A.a, b: B }, b: { tipo: 'and', a: A.b, b: B } });
        if (B.tipo === 'or') return paraDNF({ tipo: 'or', a: { tipo: 'and', a: A, b: B.a }, b: { tipo: 'and', a: A, b: B.b } });
        return { tipo: 'and', a: A, b: B };
      }
      if (node.tipo === 'not') return { tipo: 'not', a: paraDNF(node.a) };
      return clone(node);
    }

    function extrairClausulasCNF(node) {
      const clausulas = [];
      function coletarConj(n, out) {
        if (!n) return;
        if (n.tipo === 'and') { coletarConj(n.a, out); coletarConj(n.b, out); return; }
        out.push(n);
      }
      const conj = [];
      coletarConj(node, conj);
      for (const c of conj) {
        const lits = [];
        function coletarDisj(n, arr) {
          if (!n) return;
          if (n.tipo === 'or') { coletarDisj(n.a, arr); coletarDisj(n.b, arr); return; }
          arr.push(n.tipo === 'not' ? { pos: false, lit: n.a } : { pos: true, lit: n });
        }
        coletarDisj(c, lits);
        clausulas.push(lits);
      }
      return clausulas;
    }

    function ehClausulaHorn(clausula) { return clausula.filter(l => l.pos).length <= 1; }
    function classificarClausulaHorn(clausula) {
      const posCount = clausula.filter(l => l.pos).length;
      const negCount = clausula.length - posCount;
      if (posCount === 0 && negCount > 0) return 'goal';
      if (posCount === 1 && negCount === 0) return 'fact';
      if (posCount === 1 && negCount > 0) return 'rule';
      if (posCount === 0 && negCount === 0) return 'empty';
      return 'not-horn';
    }

    function clausulaParaLatex(clausula) {
      if (!clausula || !clausula.length) return '\\square';
      return clausula.map(l => l.pos ? astParaLatex(l.lit) : `\\lnot ${astParaLatex(l.lit)}`).join(' \\lor ');
    }
    function clausulasParaLatex(clausulas) {
      if (!clausulas || !clausulas.length) return '\\emptyset';
      return `\\{ ${clausulas.map(c => `(${clausulaParaLatex(c)})`).join(', ')} \\}`;
    }

    const inputEl = document.getElementById('input');
    const resultsContainer = document.getElementById('resultsContainer');
    let stepCounter = 1;
    
    function inserirSimbolo(s) {
      const el = inputEl;
      const start = el.selectionStart, end = el.selectionEnd, text = el.value;
      el.value = text.slice(0, start) + s + text.slice(end);
      el.focus();
      el.selectionStart = el.selectionEnd = start + s.length;
    }

    function definirExemplo(s) {
      inputEl.value = s;
    }

    function limparTudo() {
      inputEl.value = '';
      resultsContainer.innerHTML = '';
    }
    
    function adicionarTitulo(titulo) {
        resultsContainer.innerHTML += `<h2>${titulo}</h2>`;
    }

    function adicionarPasso(titulo, latex, extraClass = '') {
      const div = document.createElement('div');
      div.className = `step ${extraClass}`;
      div.innerHTML = `
        <div class="step-number">${stepCounter++}</div>
        <div class="step-content">
            <div class="title">${titulo}</div>
            <div class="formula">\\(${latex}\\)</div>
        </div>`;
      resultsContainer.appendChild(div);
    }
    
    function executarTudo() {
      resultsContainer.innerHTML = '';
      stepCounter = 1;
      skContador = 0; renomearContador = 0;
      const raw = inputEl.value.trim();
      if (!raw) { alert('Digite uma f√≥rmula LaTeX primeiro.'); return; }
      
      let ast;
      try {
        ast = analisar(raw);
        if (!ast) throw new Error('O parser retornou um resultado vazio. Verifique a sintaxe.');
      } catch (e) {
        adicionarTitulo("Erro");
        adicionarPasso('Erro no Parser', `\\text{${e.message || 'Entrada inv√°lida'}}`, 'error');
        console.error(e);
        MathJax.typesetPromise();
        return;
      }

      try {
        adicionarTitulo("Transforma√ß√£o para Forma Cl√°usal");
        adicionarPasso('F√≥rmula Original', astParaLatex(ast));
        const passo2 = eliminarImplicacoes(ast);
        adicionarPasso('Eliminar ‚Üí e ‚Üî', astParaLatex(passo2));
        const passo3 = paraNNF(passo2);
        adicionarPasso('NNF (Forma Normal Negativa)', astParaLatex(passo3));
        const passo4 = renomearVariaveisLigadas(passo3);
        adicionarPasso('Renomear Vari√°veis Ligadas', astParaLatex(passo4));
        const puxado = puxarQuantificadores(passo4);
        const passo5 = construirPrenex(puxado.quantificadores, puxado.matriz);
        adicionarPasso('Forma Prenex', astParaLatex(passo5));
        const passo6 = skolemizar(passo5);
        adicionarPasso('Skolemiza√ß√£o (Remover ‚àÉ)', astParaLatex(passo6));
        const passo7_cnf = paraCNF(passo6);
        adicionarPasso('CNF (Forma Normal Conjuntiva)', astParaLatex(passo7_cnf));
        const clausulas = extrairClausulasCNF(passo7_cnf);
        adicionarPasso('Forma Cl√°usal', clausulasParaLatex(clausulas));

        adicionarTitulo("An√°lise das Cl√°usulas");
        if (clausulas.length) {
          let analiseHorn = [];
          let todasHorn = true;
          clausulas.forEach((clausula, i) => {
            const ehHorn = ehClausulaHorn(clausula);
            const tipo = classificarClausulaHorn(clausula);
            if (!ehHorn && tipo !== 'empty') todasHorn = false;
            let tipoDesc = { fact: 'Fato', rule: 'Regra', goal: 'Cl√°usula Objetivo', empty: 'Cl√°usula Vazia', 'not-horn': 'N√£o-Horn' }[tipo];
            analiseHorn.push(`C_{${i + 1}}: \\underbrace{(${clausulaParaLatex(clausula)})}_{\\text{${tipoDesc}}}`);
          });
          adicionarPasso('An√°lise de Cl√°usulas de Horn', analiseHorn.join('\\\\'));
          adicionarPasso('Resumo Horn', todasHorn ? '\\text{O conjunto de cl√°usulas √© Horn.}' : '\\text{O conjunto de cl√°usulas n√£o √© Horn.}');
        } else {
          adicionarPasso('An√°lise de Cl√°usulas de Horn', '\\text{Nenhuma cl√°usula encontrada.}');
        }
        
        adicionarTitulo("Forma Alternativa (Compara√ß√£o)");
        const passo7_dnf = paraDNF(passo6);
        adicionarPasso('DNF (Forma Normal Disjuntiva)', astParaLatex(passo7_dnf));

      } catch (e) {
        adicionarTitulo("Erro");
        adicionarPasso('Erro durante a transforma√ß√£o', `\\text{${e.message || 'Erro inesperado'}}`, 'error');
        console.error(e);
      }
      MathJax.typesetPromise();
    }
  </script>
</body>
</html>